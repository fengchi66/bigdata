## Java并发编程脑图

![img](https://gitee.com/joeyooa/data-images/raw/master/node/2021/f2351fe16ea4d0533f1a3bc1d32a2624.png)

## 分工、协作、互斥

所谓**分工指的是如何高效地拆解任务并分配给线程**，而**同步指的是线程之间如何协作**，**互斥则是保证同一时刻只允许一个线程访问共享资源**。

### 分工

- Java SDK 并发包里的  Executor、Fork/Join、Future  本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 -  消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。

### 协作

- 在并发编程领域里的同步，主要指的就是**线程间的协作**，本质上和现实生活中的协作没区别，不过是**一个线程执行完了一个任务，如何通知执行后续任务的线程开工**而已。
- **协作一般是和分工相关的**。Java SDK  并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。例如，用 Future  可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get()  方法就自动返回了。主线程和异步线程之间的协作，Future 工具类已经帮我们解决了。除此之外，Java SDK 里提供的  CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。
- **当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行**。在 Java 并发编程领域，解决协作问题的核心技术是管程，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。可以这么说，**管程是解决并发问题的万能钥匙。**

### 互斥

- 所谓互斥，指的是**同一时刻，只允许一个线程访问共享变量。**
- 实现互斥的核心技术就是**锁**，Java 语言里  **synchronized**、**SDK 里的各种 Lock**  都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能呢？可以分场景优化，Java SDK  里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。
- 除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 Thread  Local 和 final 关键字，还有一种 Copy-on-write 的模式。

