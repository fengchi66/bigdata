## 主从库模式

Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

## 主线程的阻塞点

- 集合全量查询和聚合操作；
- bigkey 删除；
- 清空数据库；
- AOF 日志同步写；
- 从库加载 RDB 文件。

## Redis变慢

<img src="https://static001.geekbang.org/resource/image/cd/06/cd026801924e197f5c79828c368cd706.jpg" alt="img" style="zoom: 33%;" />

### Redis 自身操作特性的影响

- 慢查询命令，比如KEYS

  ```shell
  redis> KEYS *name*
  1) "lastname"
  2) "firstname"
  ```

- 过期 key 操作: 删除操作是阻塞的（Redis 4.0 后可以用异步线程机制来减少阻塞影响)

### 文件系统：AOF 模式

- AOF造成线程阻塞

### 操作系统：swap

### 总结

- 使用复杂度过高的命令或一次查询全量数据；
- 操作 bigkey；
- 大量 key 集中过期；
- 内存达到 maxmemory；
- 客户端使用短连接和 Redis 相连；
- 当 Redis 实例的数据量大时，无论是生成 RDB，还是 AOF 重写，都会导致 fork 耗时严重；
- AOF 的写回策略为 always，导致每个操作都要同步刷回磁盘；
- Redis 实例运行机器的内存不足，导致 swap 发生，Redis 需要到 swap 分区读取数据；
- 进程绑定 CPU 不合理；
- Redis 实例运行机器上开启了透明内存大页机制；
- 网卡压力过大。



## 数据删除后，内存占用还是很高

明明做了数据删除，数据量已经不大了，为什么使用 top 命令查看时，还会发现 Redis 占用了很多内存呢？实际上，这是因为，当数据删除后，**Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存**。

## 缓存

### 缓存淘汰策略

- 优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。
- 如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。
- 如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。

