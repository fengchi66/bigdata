## 底层数据结构

- String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）都只是redis中数据的保存形式。底层数据结构一共有 6 种，分别是简单**动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组**

### 键和值用什么结构组织？

- 全局哈希表：为了实现从键到值的快速访问，Redis 使用了一个**哈希表**来保存所有键值对。不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。不管值是 String，还是集合类型，**哈希桶中的元素都是指向它们的指针。**

  ![img](https://gitee.com/joeyooa/data-images/raw/master/node/2021/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg)

### 哈希冲突

- 哈希冲突，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。Redis 解决哈希冲突的方式，就是**链式哈希**。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

![img](https://gitee.com/joeyooa/data-images/raw/master/node/2021/8ac4cc6cf94968a502161f85d072e428.jpg)

### 渐进式 rehash

- 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
- 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
- 释放哈希表 1 的空间。

## 数据操作效率

- 对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。

### 压缩列表

- 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。

![img](https://gitee.com/joeyooa/data-images/raw/master/node/2021/9587e483f6ea82f560ff10484aaca4a0.jpg)

### 跳跃表

- 在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位

![img](https://gitee.com/joeyooa/data-images/raw/master/node/2021/1eca7135d38de2yy16681c2bbc4f3fb4.jpg)

### 不同数据结构的时间复杂度

![img](https://gitee.com/joeyooa/data-images/raw/master/node/2021/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)



## 单线程 Redis 为什么那么快？

- 我们通常说，Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。
- 为什么快？内存访问、高效的底层数据结构、多路复用IO机制。

## Redis 为什么用单线程？

- 多线程编程模式面临的共享资源的并发访问控制问题。
- 线程切换需要额外的开销

## 基于多路复用的高性能 I/O 模型

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，**不会阻塞在某一个特定的客户端请求处理上**。正因为此，**Redis 可以同时和多个客户端连接并处理请求，从而提升并发性**。

