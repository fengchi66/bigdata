## 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先**排好序**，可以在**对数**时间复杂度内完成查找。

二分查找事实上采用的就是一种分治策略，它充分利用了元素间的次序关系，可在最坏的情况下用O(log n)完成搜索任务。

它的基本思想是：假设数组元素呈升序排列，将n个元素分成个数大致相同的两半，取a[n/2]与欲查找的x作比较，如果x=a[n/2]则找到x，算法终止；如 果x<a[n/2]，则我们只要[数组的左半部继续搜索x；如果x>a[n/2]，则我们只要在数组a的右 半部继续搜索x。

![src=http___upload-images.jianshu.io_upload_images_3407530-8a8cc267133b66d5.png&refer=http___upload-images.jianshu](https://gitee.com/joeyooa/data-images/raw/master/note/2021/src=http___upload-images.jianshu.io_upload_images_3407530-8a8cc267133b66d5.png&refer=http___upload-images.jianshu.jpeg)

**基于有序数组二分查找代码**

```java
public static int search(int[] nums, int key) {

        int low = 0;
        int high = nums.length -1;

        if (key < nums[low] || key > nums[high])
            return -1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (nums[mid] < key)
                low = mid + 1;
            else if (nums[mid] > key)
                high = mid -1;
            else
                return mid;
            }

        return -1;
    }
```

**递归方式实现**

我们总结一下二分查找：

- 优点是比较次数少，查找速度快，平均性能好；

- 缺点是要求待查表为有序表，且插入删除困难。

因此，二分查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。

## 搜索二维矩阵Q74

**题目说明**

>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
>
>- 每行中的整数从左到右按升序排列。
>
>- 每行的第一个整数大于前一行的最后一个整数。
>
>![image-20210624153110315](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210624153110315.png)
>
>输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3
>
>输出：true

**分析**

既然这是一个查找元素的问题，并且数组已经排好序，我们自然可以想到用二分查找是一个高效的查找方式。

输入的 m x n 矩阵可以视为长度为 m x n的有序数组：

![image-20210624153340194](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210624153340194.png)

- 行列坐标为(row, col)的元素，展开之后索引下标为idx = row * n + col；
- 反过来，对于一维下标为idx的元素，对应二维数组中的坐标就应该是：row = idx / n;  col = idx % n;

**实现**

```java
public boolean searchMatrix(int[][] matrix, int target) {

       int m = matrix.length;
        if (m == 0) return false; 
        int n = matrix[0].length;
        int left = 0;
        int right = m * n - 1;

				// 二分查找，定义左右指针
        while ( left <= right ){
            int midIdx = (left + right) / 2;   
            int midElement = matrix[midIdx/n][midIdx%n];
            if ( midElement < target )
                left = midIdx + 1; 
            else if ( midElement > target )
                right = midIdx - 1; 
            else
                return true;    // 找到target
        }

        return false;

    }
```

**复杂度分析**

- 时间复杂度 : 由于是标准的二分查找，时间复杂度为O(log(m n))。

- 空间复杂度 : 没有用到额外的空间，复杂度为O(1)。

## 寻找重复数Q287

**题目说明**

> 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
>
> 示例
>
> 输入: [1,3,4,2,2]
>
> 输出: 2
>
> - 不能更改原数组（假设数组是只读的）。
>
> - 只能使用额外的 O(1) 的空间。
>
> - 时间复杂度小于 O(n2) 。
>
> - 数组中只有一个重复的数字，但它可能不止重复出现一次

**分析**

怎样证明 nums 中存在至少一个重复值？其实很简单，这是`抽屉原理`（或者叫“鸽子洞原理”）的简单应用。

这里，nums 中的每个数字（n+1个）都是一个物品，nums 中可以出现的每个不同的数字（n个）都是一个 `抽屉`。把n+1 个物品放入n个抽屉中，必然至少会有一个抽屉放了2个或者2个以上的物品。所以这意味着nums中至少有一个数是重复的。

### 保存元素法(存入HashMap)

```java
public int findDuplicate(int[] nums) {

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

        for (int num : nums) {
            if (map.get(num) == null) // map中没有该元素的key，存进去
                map.put(num, 1);
            else // 已经有了，当前的元素就是重复元素
            return num;
        }
        return -1;
    }
```

### 保存元素到Set

思路和以上一致

```java
public int findDuplicate2(int[] nums) {

        HashSet<Integer> set = new HashSet<Integer>();

        for (int num : nums) {
            if (!set.contains(num))
                set.add(num);
            else
                return num;
        }
        return -1;
    }
```

