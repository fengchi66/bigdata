## 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先**排好序**，可以在**对数**时间复杂度内完成查找。

二分查找事实上采用的就是一种分治策略，它充分利用了元素间的次序关系，可在最坏的情况下用O(log n)完成搜索任务。

它的基本思想是：假设数组元素呈升序排列，将n个元素分成个数大致相同的两半，取a[n/2]与欲查找的x作比较，如果x=a[n/2]则找到x，算法终止；如 果x<a[n/2]，则我们只要[数组的左半部继续搜索x；如果x>a[n/2]，则我们只要在数组a的右 半部继续搜索x。

![src=http___upload-images.jianshu.io_upload_images_3407530-8a8cc267133b66d5.png&refer=http___upload-images.jianshu](https://gitee.com/joeyooa/data-images/raw/master/note/2021/src=http___upload-images.jianshu.io_upload_images_3407530-8a8cc267133b66d5.png&refer=http___upload-images.jianshu.jpeg)

**基于有序数组二分查找代码**

```java
public static int search(int[] nums, int key) {

        int low = 0;
        int high = nums.length -1;

        if (key < nums[low] || key > nums[high])
            return -1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (nums[mid] < key)
                low = mid + 1;
            else if (nums[mid] > key)
                high = mid -1;
            else
                return mid;
            }

        return -1;
    }
```

**递归方式实现**

```java
    // 递归方式实现二分查找,增加搜索的上下界作为参数
    public static int search(int[] nums, int key, int from, int to) {

        // 基本判断，当起始位置大于结束位置时，直接返回 -1；特殊情况超出最大最小值直接返回 -1
        if (key < nums[from] || key > nums[to] || from > to)
            return -1;

        // 计算中间位置
        int mid = (from + to)/2;

        // 判断中间位置和key的关系，更改搜索范围，递归调用
        if (nums[mid] < key)
            return search(nums, key, mid + 1, to);
        else if (nums[mid] > key)
            return search(nums, key, from, mid - 1);
        else
            return mid;
    }
```



我们总结一下二分查找：

- 优点是比较次数少，查找速度快，平均性能好；

- 缺点是要求待查表为有序表，且插入删除困难。

因此，二分查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。

## 搜索二维矩阵Q74

**题目说明**

>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
>
>- 每行中的整数从左到右按升序排列。
>
>- 每行的第一个整数大于前一行的最后一个整数。
>
>![image-20210624153110315](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210624153110315.png)
>
>输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3
>
>输出：true

**分析**

既然这是一个查找元素的问题，并且数组已经排好序，我们自然可以想到用二分查找是一个高效的查找方式。

输入的 m x n 矩阵可以视为长度为 m x n的有序数组：

![image-20210624153340194](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210624153340194.png)

- 行列坐标为(row, col)的元素，展开之后索引下标为idx = row * n + col；
- 反过来，对于一维下标为idx的元素，对应二维数组中的坐标就应该是：row = idx / n;  col = idx % n;

**实现**

```java
public boolean searchMatrix(int[][] matrix, int target) {

       int m = matrix.length;
        if (m == 0) return false; 
        int n = matrix[0].length;
        int left = 0;
        int right = m * n - 1;

				// 二分查找，定义左右指针
        while ( left <= right ){
            int midIdx = (left + right) / 2;   
            int midElement = matrix[midIdx/n][midIdx%n];
            if ( midElement < target )
                left = midIdx + 1; 
            else if ( midElement > target )
                right = midIdx - 1; 
            else
                return true;    // 找到target
        }

        return false;

    }
```

**复杂度分析**

- 时间复杂度 : 由于是标准的二分查找，时间复杂度为O(log(m n))。

- 空间复杂度 : 没有用到额外的空间，复杂度为O(1)。

## 寻找重复数Q287

**题目说明**

> 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
>
> 示例
>
> 输入: [1,3,4,2,2]
>
> 输出: 2
>
> - 不能更改原数组（假设数组是只读的）。
>
> - 只能使用额外的 O(1) 的空间。
>
> - 时间复杂度小于 O(n2) 。
>
> - 数组中只有一个重复的数字，但它可能不止重复出现一次

**分析**

怎样证明 nums 中存在至少一个重复值？其实很简单，这是`抽屉原理`（或者叫“鸽子洞原理”）的简单应用。

这里，nums 中的每个数字（n+1个）都是一个物品，nums 中可以出现的每个不同的数字（n个）都是一个 `抽屉`。把n+1 个物品放入n个抽屉中，必然至少会有一个抽屉放了2个或者2个以上的物品。所以这意味着nums中至少有一个数是重复的。

### 保存元素法(存入HashMap)

```java
public int findDuplicate(int[] nums) {

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

        for (int num : nums) {
            if (map.get(num) == null) // map中没有该元素的key，存进去
                map.put(num, 1);
            else // 已经有了，当前的元素就是重复元素
            return num;
        }
        return -1;
    }
```

### 保存元素到Set

思路和以上一致

```java
public int findDuplicate2(int[] nums) {

        HashSet<Integer> set = new HashSet<Integer>();

        for (int num : nums) {
            if (!set.contains(num))
                set.add(num);
            else
                return num;
        }
        return -1;
    }
```

### 排序法

我们可以先在原数组上排序。

排序之后，所有重复的数会排在一起；这样，只要我们遍历的时候发现连续两个元素相等，就可以输出结果了。

```java
 // 先排序, 然后找相邻的相同元素,
    public int findDuplicate3(int[] nums) {

        // 排序
        Arrays.sort(nums);

        // 遍历数组元素，遇到跟前一个相同的，就是相邻元素
        for (int i = 1; i < nums.length; i++)
            if (nums[i] == nums[i - 1])
                return nums[i];

        return -1;
    }
```

**复杂度分析**

- 时间复杂度： O(nlgn)。对数组排序，在Java 中要花费 O(nlgn) 时间，后续是一个线性扫描，所以总的时间复杂度是O(nlgn)。

- 空间复杂度： O(1) (or O(n))，在这里，我们对 nums 进行了排序，因此内存大小是固定的。当然，这里的前提是我们可以用常数的空间，在原数组上直接排序。如果我们不能修改输入数组，那么我们必须把 nums 拷贝出来，并进行排序，这需要分配线性的额外空间。

### 二分查找

这道题目中数组其实是很特殊的，我们可以从原始的 [1, N] 的自然数序列开始想。现在增加到了N+1个数，根据抽屉原理，肯定会有重复数。对于增加重复数的方式，整体应该有两种可能：

- 如果重复数（比如叫做target）只出现两次，那么其实就是1~N所有数都出现了一次，然后再加一个target；

- 如果重复数target出现多次，那在情况1的基础上，它每多出现一次，就会导致1~N中的其它数少一个。

例如：1~9之间的10个数的数组，重复数是6：

```
1，2，5，6，6，6，6，6，7，9
```

本来最简单（重复数出现两次，其它1~9的数都出现一次）的是

```
1，2，3，4，5，6，6，7，8，9
```

现在没有3、4和8，所以6会多出现3次。

我们可以发现一个规律： 

- 以target为界，对于比target小的数i，数组中所有小于等于它的数，最多出现一次（有可能被多出现的target占用了），所以总个数不会超过i。

- 对于比target大的数j，如果每个元素都只出现一次，那么所有小于等于它的元素是j个；而现在target会重复出现，所以总数一定会大于j。

用数学化的语言描述就是：

> 我们把对于1~N内的某个数i，在数组中小于等于它的所有元素的个数，记为count[i]。
>
> 则：当i属于[1, target-1]范围内，count[i] <= i；当i属于[target, N]范围内，count[i] > i。

所以要找target，其实就是要找1~N中这个分界的数。所以我们可以对1~N的N个自然数进行二分查找，它们可以看作一个排好序的数组，但不占用额外的空间。

 ```java
         // 二分查找
         public int findDuplicate4(int[] nums) {
 
             int l = 1;
             int r = nums.length - 1;
 
             // 二分查找
             while (l <= r) {
                 int i = (l + r) / 2;
                 // 对当前i计算count[i]
                 int count = 0;
                 for (int j = 0; j < nums.length; j++) {
                     if (nums[j] <= i)
                         count++;
                 }
                 // 判断count[i]和i的大小关系
                 if (count <= i)
                     l = i + 1;
                 else
                     r = i;
                 // 找到target
                 if (l == r)
                     return l;
             }
             return -1;
         }
 ```

