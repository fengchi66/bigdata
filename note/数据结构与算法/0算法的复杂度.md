基于算法的有穷性，我们可以知道算法运行消耗的时间不能是无限的。而对于一个问题的处理，可能有多个不同的算法，它们消耗的时间一般是不同的；运行过程中占用的空间资源也是不同的。

这就涉及到对算法的性能考察。主要有两方面：时间和空间。在计算机算法理论中，用时间复杂度和空间复杂度来分别从这两方面衡量算法的性能。

## 时间复杂度（Time Complexity）

要想衡量代码的“工作量”，我们需要将每一行代码，拆解成计算机能执行一条条“基本指令”。这样代码的执行时间，就可以用“基本指令”的数量来表示了。

真实的计算机系统里，基本指令包括：

- 算术指令（加减乘除、取余、向上向下取整）
- 数据移动指令（装载、存储、赋值）
- 控制指令（条件或无条件跳转，子程序调用和返回）。

### 基本指令-程序执行消耗的时间单位

- int a = 1，简单赋值操作，运行时间 1（1个单位）
- if ( a > 1) {}，简单判断操作、条件跳转，运行时间 1
- for(int i = 0; i < N; i++) {println(i)}，有循环，运行时间 1（i赋初值）+ N+1（判断）+N（打印）+N（i自增）= 3N + 2

因此算法的时间复杂度，应该考虑到底**有多少条基本指令**。

- 比起代码具体运行的时间，我们更关心的是，当它的输入规模增长的时候，它的执行时间我们是否还能够接受。

- 不同的算法，运行时间随着输入规模 n 的增长速度是不同的。我们可以把代码执行时间，表示成输入规模n的函数T(n)。

![image-20210621224047997](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210621224047997.png)

### 复杂度的大O表示法

**对于给定的函数g(n)，我们用O(g(n))来表示以下函数的集合:**

- O(g(n)) = { f(n): 存在正常量 c 和 n0，使对所有 n≥n0 ，有 0≤f(n) ≤ cg(n) }
- 算法分析中，一般用大O符号来表示函数的 渐进上界
- 这表示，当数据量达到一定程度时，g(n) 的增长速度不会超过 O(g(n)) 限定的范围

### 常见的时间复杂度

![image-20210621225147298](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210621225147298.png)

## 空间复杂度

算法的空间复杂度，是指算法需要消耗的内存空间。

- Array[100] ： O(100)
- Array[N] ： O(N)
- int val = 1;   空间复杂度 O(1)

有时候递归调用，需要计算调用栈所占用的空间。

## 算法的分类

可以用两种不同的原则，来对算法做一个分类整理：

###  按照应用的目的来划分

搜索算法、排序算法、字符串算法、图算法、最优化算法、数学（数论）算法

### 按照具体实现的策略划分

暴力法、增量法、分治法、贪心、动态规划、回溯、分支限界法

![image-20210621225752503](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210621225752503.png)

## 经典算法

在实际应用中，有一些经典算法和策略，都可以作为解决问题的思路：

- 二分查找

- 快速排序、归并排序

- KMP算法

- 快慢指针（双指针法）

- 普利姆（Prim）和 克鲁斯卡尔（Kruskal）算法

- 迪克斯特拉（Dijkstra）算法

- 其它优化算法：模拟退火、蚁群、遗传算法