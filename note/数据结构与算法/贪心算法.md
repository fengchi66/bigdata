## 贪心算法

- 最自然智慧的算法
- **用一个局部最功利的标准，总是做出在当前看来是最好的选择**
- **难点在于证明局部最功利的标准可以得到全局最优解**
- 对于贪心算法的学习主要以增加阅历和经验为主

## 贪心求解

### 最小字符串

给定一个由字符串组成的数组，必须把所有的字符串拼接起来，**返回所有可能的拼接结果中，字典序最小的结果**。

#### 贪心策略

**a和b是字符串数组中的两个元素，对于a和b，如果 a + b < b + a的字典序，则将a放前面，否则将b放前面，其中a + b表示a和b字符串拼接。**

#### 证明

- 排序策略是有传递性的，**如果a + b < b < a且 b +c < c + b, 则 a +c < c +a。**
-  **若 a 和 b 排好序，若交换 a 和 b，则一定会造成字典序只增不减。**

#### 步骤

- 提过贪心策略
- 使用对数器排序

**代码**

```java
 /**
     * 比较器: 贪心策略
     */
    public static class MyComparator implements Comparator<String> {
        @Override
        public int compare(String a, String b) {
            return (a + b).compareTo(b + a);
        }
    }

    public static String lowestString(String[] strs) {
        if (strs == null || strs.length == 0)
            return "";

        // 对数组按照定义好的比较器排序
        Arrays.sort(strs, new MyComparator());

        String res = "";
        for (int i = 0; i < strs.length; i++) {
            res += strs[i];
        }
        return res;
    }
```

## 贪心算法解题套路

### 会议室宣讲项目最多

题目：一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次

#### 贪心策略

- 每次会议都选结束时间最早的，然后安排下一次会议，局部最优解，使安排次数最多，得到全局最优解。
- 将会议按照结束时间升序排序，然后对这个数组遍历：如果第一次会议结束的时间不大于第二次会议的开始时间，则可以安排一次会议。
- 这里的边界就是**每次会议的结束时间和下次会议的开始时间**。

**代码实现**

```java
 // 会议实体类
    public static class Program {
        public int start;
        public int end;

        public Program(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    // 会议的开始时间和结束时间，都是数值，不会 < 0
    public static int bestArrange2(Program[] programs) {
        // 按会议结束时间升序
        Arrays.sort(programs, new ProgramComparator());

        // 一开始的时间点来到0，安排的次数为0
        int timeLine = 0;
        int res = 0;
        for (int i = 0; i < programs.length; i++) {
            if (timeLine <= programs[i].start) { // 如果当前时间点小于下一次会议的开始时间，则可以安排一次会议
                res ++;
                timeLine = programs[i].end;
            }
        }
        return res;
    }

    // 自定义排序：会议结束时间短的排前面
    public static class ProgramComparator implements Comparator<Program> {
        @Override
        public int compare(Program o1, Program o2) {
            return o1.end - o2.end;
        }
    }
```



