## 暴力递归到动态规划

## 动态规划数组压缩

### 二维数组最小距离

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角。沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和。请问最小距离累加和是多少？

- 每一个位置只有两种选择，向左或者向右走。
- `定义dp[i][j]表示从左上角位置出发，到达[i,j]的最优解。那么最后返回dp[row - 1][col - 1]即是从左上角到右下角的最优解`

```java
// 动态规划方法：dp[i][j]表示从左上角出发到[i,j]位置的最小路径和
    public static int minPathSum1(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0)
            return 0;

        int row = m.length;
        int col = m[0].length;

        int[][] dp = new int[row][col];
        dp[0][0] = m[0][0];

        // 填表的第一行以及第一列
        for (int i = 1; i < row; i++)
            dp[i][0] = dp[i -1][0] + m[i][0];

        for (int j = 1; j < col; j++)
            dp[0][j] = dp[0][j-1] + m[0][j];

        // 填dp表的其他位置
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + m[i][j];
            }
        }
        return dp[row-1][col-1];
    }
```

#### 空间压缩

在上面做法中，我们将一个原始矩阵转换为一个等规模的DP表，浪费空间。在dp方程中，`dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + m[i][j];`，`dp[i][j]`位置的`值只依赖它的上面和左边位置的值`，其他位置的值就不再需要了。

- 定义一个数组，存原DP表中第0行的值。
- 依次更新数组，让它存第一行、第二行...直到第row - 1行的值，最后返回dp[col -1]即可。

```java
public static int minPathSum2(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 0;
		}
		int row = m.length;
		int col = m[0].length;
		int[] dp = new int[col];
  	// 初始化dp[0]就是左上角的值
		dp[0] = m[0][0];
		for (int j = 1; j < col; j++) {
      // 填第一行的值
			dp[j] = dp[j - 1] + m[0][j];
		}
		for (int i = 1; i < row; i++) {
      // 向下遍历，dp[0]赋值
			dp[0] += m[i][0];
			for (int j = 1; j < col; j++) {
        // 左边的值和上面的值比较,会面这个dp[j]此时还没有赋值，因此还是上一次赋值的值
				dp[j] = Math.min(dp[j - 1], dp[j]) + m[i][j];
			}
		}
		return dp[col - 1];
	}
```

**空间压缩小技巧：**

凡是涉及到依赖关系类似`dp[i][j]`位置的`值只依赖它的上面和左边位置的值`，都可以使用空间压缩。

### 换钱的方法数

给出货币数组arr，均为正数，每个值都认为是一张货币，认为值相同的货币没有任何不同，现给出一个正数aim，返回组成aim的方法数。

例如：arr = {1,2,1,1,2,1,2}，aim = 4，方法：1+1+1+1、1+1+2、2+2，一共三种方法，因此返回3。

#### 暴力递归

- **从左往右的尝试模型**
- **递归函数**
  - 表示从index位置出发自由选择，组成正好rest这么多钱的方法数
  - base case：`index到达arr.length位置且刚好rest=0，计一次方法数`



```java
public static int coinWays(int[] arr, int aim) {
        return process(arr, 0, aim);
    }

    // arr[index...]，从index位置出发自由选择，组成正好rest这么多的钱有几种方法
    public static int process(int[] arr, int index, int rest) {
        if (rest < 0) {
            return 0;
        }
        if (index == arr.length) { // 没钱了！
            return rest == 0 ? 1 : 0;
        } else {
            return process(arr, index + 1, rest) + process(arr, index + 1, rest - arr[index]);
        }
    }
```

#### 动态规划

- `DP表dp[index][rest]表示从从index位置出发自由选择，组成正好rest这么多钱的方法数`，与递归的含义一致。
- `dp[index]`位置依赖于`dp[index + 1]位置的值`，先将dp[N]赋值后从N-1位置出发，依次填上表其他位置的值，最后返回`dp[0][aim]`。

```java
public static int dp(int[] arr, int aim) {
        if (aim == 0) {
            return 1;
        }
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        // base case
        dp[N][0] = 1;
        // 依赖关系dp[index]依赖dp[index +1]
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest] = dp[index + 1][rest] + (rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : 0);
            }
        }
        return dp[0][aim];
    }
```

