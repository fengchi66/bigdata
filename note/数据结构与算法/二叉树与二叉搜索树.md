## 基本概念

树是一种非线性数据结构。树结构的基本单位是节点。节点之间的链接，称为分支（branch）。节点与分支形成树状，结构的开端，称为**根（root）**，或根结点。根节点之外的节点，称为**子节点（child）**。没有链接到其他子节点的节点，称为**叶节点（leaf**）。如下图是一个典型的树结构：

![image-20210702164308779](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210702164308779.png)

**每个节点可以用以下数据结构来表示: (二叉树)**

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {}
    TreeNode(int val) {this.val = val;}
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

其他重要概念：

- **树的高度**：节点到叶子节点的最大值就是其高度。
- **树的深度**：高度和深度是相反的，高度是从下往上数，深度是从上往下。因此根节点的深度和叶子节点的高度是 0。
- **树的层**：根开始定义，**根为第一层，根的孩子为第二层**。
- **二叉树**，三叉树，。。。 N 叉树，由其子节点最多可以有几个决定，最多有 N 个就是 N 叉树。

## 二叉树的遍历

二叉树是树结构的一种，两个叉就是说每个节点**最多**只有两个子节点，我们习惯称之为左节点和右节点。

遍历二叉树的方法主要有以下几种:

- 前序遍历
- 中序遍历
- 后续遍历
- 层序遍历

![img](https://gitee.com/joeyooa/data-images/raw/master/note/2021/ff26c3f4485c043a17923c3dcab65891f0d32c45e1400c36364e5084462bf2e4.png)

- 如果按照 **根节点 -> 左孩子 -> 右孩子** 的方式遍历，即「前序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7；

- 同理，如果你按照 **左孩子 -> 根节点 -> 右孩子** 的方式遍历，即「中序遍历」，遍历结果为 4 2 5 1 6 3 7；

- 如果你按照 **左孩子 -> 右孩子 -> 根节点** 的方式遍历，即「后序遍历」，遍历结果为 4 5 2 6 7 3 1；

- 最后，层次遍历就是按照每一层从左向右的方式进行遍历，遍历结果为 1 2 3 4 5 6 7。

### 递归解法

#### 前序遍历

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) return;
    System.out.print(head.val + " ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}
```

#### 中序遍历

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) return;
    preOrderRecur(head.left);
    System.out.print(head.val + " ")
    preOrderRecur(head.right);
}
```

#### 后续遍历

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) return;
    preOrderRecur(head.left);
    preOrderRecur(head.right);
    System.out.print(head.val + " ")
}
```

**复杂度分析**

- 时间复杂度：O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。

- 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。

### 迭代解法

本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用`Stack`来模拟系统栈。

#### 前序遍历

使用栈来进行迭代，过程如下：

- **初始化栈，并将根节点入栈；**
  **当栈不为空时：**

  - **弹出栈顶元素 node，并将值添加到结果中；**
  - **如果 node 的右子树非空，将右子树入栈；**
  - **如果 node 的左子树非空，将左子树入栈；**

  ![中序遍历流程图](https://gitee.com/joeyooa/data-images/raw/master/note/2021/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png)

由于栈是“先进后出”的顺序，所以**入栈时先将右子树入栈，这样使得前序遍历结果为 “根->左->右”的顺序**。

```java
 	public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root;
        while(cur != null || !s.isEmpty()){
            if(cur != null){
                res.add(cur.val); // root
                s.push(cur); 
                cur = cur.left; // left
            }else{
                cur = s.pop();
                cur = cur.right; // right
            }
        }
        return res;
    }
```

#### 中序遍历

```java
	public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()){
            if(cur != null){ 
                stack.push(cur);
                cur = cur.left; // left
            }else{
                cur = stack.pop();
                res.add(cur.val); // root
                cur = cur.right; // right
            }
        }
        return res;
    }
```

#### 后续遍历

- 前序遍历顺序为：根 -> 左 -> 右
- 后序遍历顺序为：左 -> 右 -> 根
- 所以, 可以**把前序遍历的稍作修改: 根 -> 右 -> 左,  然后结果存放到栈里进行倒序, 之后再遍历结果栈就可以输出后序遍历了**

```java
    public List<Integer> postorderTraversal(TreeNode root) {
        Stack<TreeNode> s = new Stack<>();
        Stack<TreeNode> resStack = new Stack<>();
        TreeNode cur = root;
        while(cur != null || !s.isEmpty()){
            if(cur != null){
                resStack.push(cur); // root
                s.push(cur); 
                cur = cur.right; // right
            }else{
                cur = s.pop();
                cur = cur.left; // left
            }
        }

        List<Integer> res = new ArrayList<>();
        while(!resStack.isEmpty()){
            res.add(resStack.pop().val);
        }
        return res;
    }
```

## 二叉搜索树

二叉搜索树，也称二叉搜索树、有序二叉树（Ordered Binary Tree）、 排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的 二叉树： 

- 左子树上所有结点的值均小于它的根结点的值； 
- 右子树上所有结点的值均大于它的根结点的值； 
- 以此类推：左、右子树也分别为二叉查找树(重复性)

**二叉搜索树的一个特征是中序遍历后升序排列。**

