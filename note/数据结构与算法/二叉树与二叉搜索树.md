##  基本概念

树是一种非线性数据结构。树结构的基本单位是节点。节点之间的链接，称为分支（branch）。节点与分支形成树状，结构的开端，称为**根（root）**，或根结点。根节点之外的节点，称为**子节点（child）**。没有链接到其他子节点的节点，称为**叶节点（leaf**）。如下图是一个典型的树结构：

![image-20210702164308779](https://gitee.com/joeyooa/data-images/raw/master/note/2021/image-20210702164308779.png)

**每个节点可以用以下数据结构来表示: (二叉树)**

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {}
    TreeNode(int val) {this.val = val;}
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

其他重要概念：

- **树的高度**：节点到叶子节点的最大值就是其高度。
- **树的深度**：高度和深度是相反的，高度是从下往上数，深度是从上往下。因此根节点的深度和叶子节点的高度是 0。
- **树的层**：根开始定义，**根为第一层，根的孩子为第二层**。
- **二叉树**，三叉树，。。。 N 叉树，由其子节点最多可以有几个决定，最多有 N 个就是 N 叉树。

## 二叉树的遍历

二叉树是树结构的一种，两个叉就是说每个节点**最多**只有两个子节点，我们习惯称之为左节点和右节点。

遍历二叉树的方法主要有以下几种:

- 前序遍历
- 中序遍历
- 后续遍历
- 层序遍历

![img](https://gitee.com/joeyooa/data-images/raw/master/note/2021/ff26c3f4485c043a17923c3dcab65891f0d32c45e1400c36364e5084462bf2e4.png)

- 如果按照 **根节点 -> 左孩子 -> 右孩子** 的方式遍历，即「前序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7；

- 同理，如果你按照 **左孩子 -> 根节点 -> 右孩子** 的方式遍历，即「中序遍历」，遍历结果为 4 2 5 1 6 3 7；

- 如果你按照 **左孩子 -> 右孩子 -> 根节点** 的方式遍历，即「后序遍历」，遍历结果为 4 5 2 6 7 3 1；

- 最后，层次遍历就是按照每一层从左向右的方式进行遍历，遍历结果为 1 2 3 4 5 6 7。

### 递归解法

#### 递归序

- **理解递归序**
- 前序、中序、后续都可以在递归序的基础上加工出来
- 第一次到达一个节点就打印就是先序、第二次打印即中序，第三次是后续

#### 前序遍历

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) return;
    System.out.print(head.val + " ");
    preOrderRecur(head.left); 
    preOrderRecur(head.right);
}
```

#### 中序遍历

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) return;
    preOrderRecur(head.left);
    System.out.print(head.val + " ")
    preOrderRecur(head.right);
}
```

#### 后续遍历

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) return;
    preOrderRecur(head.left);
    preOrderRecur(head.right);
    System.out.print(head.val + " ")
}
```

**复杂度分析**

- 时间复杂度：O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。

- 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。

### 迭代解法

本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用`Stack`来模拟系统栈。

#### 前序遍历

使用栈来进行迭代，过程如下：

- **初始化栈，并将根节点入栈；**
  **当栈不为空时：**

  - **弹出栈顶元素 node，并将值添加到结果中；**
  - **如果 node 的右子树非空，将右子树入栈；**
  - **如果 node 的左子树非空，将左子树入栈；**

  ![中序遍历流程图](https://gitee.com/joeyooa/data-images/raw/master/note/2021/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png)

由于栈是“先进后出”的顺序，所以**入栈时先将右子树入栈，这样使得前序遍历结果为 “根->左->右”的顺序**。

```java
 	public List<Integer> preorderTraversal2(TreeNode root) {

        ArrayList<Integer> res = new ArrayList<>();

        if (root  == null) return res;

        // 将root结点加入到res中
        Stack<TreeNode> stack = new Stack<>();
        stack.add(root);

        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            res.add(node.val);

            // 有孩子将先右孩子加入栈
            if (node.right != null)
                stack.push(node.right);
            // 有孩子将先右孩子加入栈
            if (node.left != null)
                stack.push(node.left);
        }
        return res;
    }
```

#### 中序遍历

- 当前结点cur，以cur为头的树的整个左边界入栈，直到遇到空。
- 当遇到空的之后，从栈中弹出结点cur打印，让这个结点右孩子成为cur。

```java
	public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()){
            if(cur != null){ 
                stack.push(cur);
                cur = cur.left; // left
            }else{
                cur = stack.pop();
                res.add(cur.val); // root
                cur = cur.right; // right
            }
        }
        return res;
    }
```

#### 后续遍历

- 前序遍历顺序为：根 -> 左 -> 右
- 后序遍历顺序为：左 -> 右 -> 根
- 所以, 可以**把前序遍历的稍作修改: 根 -> 右 -> 左,  然后结果存放到栈里进行倒序, 之后再遍历结果栈就可以输出后序遍历了**

```java
   public List<Integer> postorderTraversal(TreeNode root) {

        ArrayList<Integer> res = new ArrayList<>();

        if (root == null) return res;

        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();

        // 模拟前序遍历，现将root加入s1中
        s1.push(root);

        while (!s1.isEmpty()) {
            // 从s1中弹出元素加入s2中
            root = s1.pop();
            s2.push(root);

            if (root.left != null)
                s1.push(root.left);
            if (root.right != null)
                s1.push(root.right);
        }
        // 所有元素都按照：头 -> 右 - > 左加入到s2了,从s2取出来就是 左 -> 右 -> 头的关系(后序)
        while (!s2.isEmpty())
            res.add(s2.pop().val);

        return res;
    }
```

#### 层序遍历

- 其实就是宽度优先遍历，用队列
- 可以通过设置flag变量，来发现某一层的结束

```java
 public void levelOrder(TreeNode root) {
        
        if (root == null) return;

        Queue<TreeNode> queue = new LinkedList<>();
        // 首先将头节点加入到queue中
        queue.add(root);
        
        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            System.out.println(cur.val);
            
            // cur有左孩子先将左孩子加入队列
            if (cur.left != null)
                queue.add(cur.left);

            // 然后将右孩子加入队列 
            if (cur.right != null)
                queue.add(cur.right);
        }
    }
```

## 二叉树序列化与反序列化

序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。

树的结构和字符串一一对应。

### 先序方式

#### 序列化

- 先序遍历，遇到null给一个特殊字符`#`
- 每个结点值之间字符串用`,`分割

```java
public static Queue<String> preSerial(Node root) {
        Queue<String> res = new LinkedList<>();
        pres(root, res);
        
        return res;
    }
    
    // 先序遍历,遇到null时将null加入到队列中
    public static void pres(Node root, Queue<String> res) {
        if (root == null) {
            res.add(null);
        } else { // 不为null时分别遍历左、右子树
            res.add(String.valueOf(root.value));
            pres(root.left, res);
            pres(root.right, res);
        }
    }
```

#### 反序列化

- 以此弹出队列中的元素，按照先序的方式依次建立结点，遇到null则返回null。

```java
public static Node buildByPreQueue(Queue<String> prelist) {
		if (prelist == null || prelist.size() == 0) {
			return null;
		}
		return preb(prelist);
	}

	public static Node preb(Queue<String> prelist) {
		String value = prelist.poll();
		if (value == null) {
			return null;
		}
		Node head = new Node(Integer.valueOf(value));
		head.left = preb(prelist);
		head.right = preb(prelist);
		return head;
	}
```

### 层序方式

#### 序列化

